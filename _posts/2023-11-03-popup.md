---
title: typescript로 popup만들기
author: leejh1316
date: 2023-11-03 22:00:00 +0900
categories: [Frontend, libray]
tags: [javascript, typescript, frontend]
render_with_liquid: false
---

웹페이지를 자주 이용하다보면 툴팁 또는 팝업 형태를 가진 요소를 자주 볼 수 있다. 이와 관련된 라이브러리가 있지만, 한번쯤은 직접 만들어 보고 싶었다. 직접 만들면서 부딪힌 상황과 해결방안을 작성해보겠다.

본론에 들어가기 앞서 결과물을 먼저 보여주겠다.

<p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="eYxBOqM" data-user="oophxzfe-the-solid" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/oophxzfe-the-solid/pen/eYxBOqM">
  Untitled</a> by 이재혁 (<a href="https://codepen.io/oophxzfe-the-solid">@oophxzfe-the-solid</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>

### 기능정리

팝업 라이브러리 들어갈 기능들을 정리했다.

- 위치 지정
- 팝업 생성
- 화면 넘어감 방지

# 구현

필요한 기능을 중심으로 하나하나씩 구현해보자

## 타입구현

typescript를 사용할 것이기 떄문에 popup 구현에 필요한 타입들을 먼저 서술하겠다.

```typescript
export interface Options {
  placement?: Placement; // 참조요소 위치 지정
  gap?: number; //참조요소와 팝업요소의 사이 공간
  mode?: Mode; // 모드 지정
  event?: Event; //이벤트 설정
}
export type Placement =
  | "top"
  | "top-right"
  | "top-left"
  | "right"
  | "right-top"
  | "right-bottom"
  | "bottom"
  | "bottom-right"
  | "bottom-left"
  | "left"
  | "left-top"
  | "left-bottom";

interface Event {
  resize?: boolean; // window.resize 이벤트 등록
  scroll?: boolean; // window.scroll 이벤트 등록
}

interface Mode {
  auto?: boolean; //위치를 자동으로 지정하는 모드
}

//좌표
export interface Coordinate {
  top: number;
  left: number;
}
```

## 위치 지정

위치를 지정하기 위해 고민해봐야 할 것이 있다.

- 팝업요소 배치위치
- 좌표지정

### 팝업요소 배치위치

팝업 요소는 body태그에 배치해야 한다.

1. 팝업요소를 부모(참조)요소의 자식으로 배치할 수 없다. 부모요소에 overflow을 적용시키면 팝업요소는 보이지 않는다. 2.버팝업요소의 position은 abdolute 이다. 부모의 position 설정값에 따라 좌표의 위치 예측이 어려워 질 수 있다.

이 문제를 통해 팝업요소는 body태그 내에 위치에해 함을 알 수 있다.

```javascript
document.parentNode.insertBefore(newNode, referenceNode);
```

이 함수는 기존 요소의 자식 목록 중 특정 자식 요소 앞에 새로운 요소를 추가한다.

- parentNode : 부모
- newNode : 삽입할 노드
- referenceNode : newNode를 referenceNode앞에 삽입, null이라면 가장 뒤에 삽입된다.

### 좌표지정

팝업의 좌표는 절대좌표로 지정해야 한다.

절대좌표를 구하는 대표적인 방법은 다음과 같다.

```javascript
const element = document.getElementById("yourElementId"); // 요소 선택 또는 참조

const rect = element.getBoundingClientRect(); // 요소의 위치 및 크기 정보 가져오기

const absoluteTop = rect.top + window.scrollY; // 절대적인 상단 좌표
const absoluteLeft = rect.left + window.scrollX; // 절대적인 왼쪽 좌표

console.log("절대적인 상단 좌표:", absoluteTop);
console.log("절대적인 왼쪽 좌표:", absoluteLeft);
```

> element.getBoundingClientRect() : 해당 함수는 요소의 viewport 를 기준으로한 상대적인 좌표와 요소의 사이즈를알려주는 함수다. DOMRect 객체를 반환한다.

이를 응용하여 팝업요소의 위치를 총 12군데를 지정했으며,전략패턴을 이용했다.

> 전략패턴 : 다양한 알고리즘을 정의하고 각각을 독립적으로 캡슐화하여 교환 가능하게 만드는 디자인 패턴이다. 컨텍스트 객체가 다양한 전략을 선택하여 실행할 수 있도록 한다.

- 추상 클래스

```ts
export abstract class PlacementStrategy {
  protected referenceRect: DOMRect;
  protected popupRect: DOMRect;
  protected options: Options; //popup 옵션
  protected coord: Coordinate; //popup 좌표
  constructor(referenceRect: DOMRect, popupRect: DOMRect, options: Options) {
    this.referenceRect = referenceRect;
    this.popupRect = popupRect;
    this.options = options;
    this.coord = this.getCoordinate();
  }
  abstract getPlacementName(): Placement;
  abstract getCoordinate(): Coordinate; //팝업요소의 좌표를 구하는 함수
}
```

- top

```ts
export class PlacementTop extends PlacementStrategy {
  getPlacementName(): Placement {
    return "top";
  }
  getCoordinate(): Coordinate {
    return {
      top:
        this.referenceRect.top +
        scrollY -
        this.popupRect.height -
        this.options.gap,
      left:
        this.referenceRect.width / 2 +
        (this.referenceRect.left + scrollX) -
        this.popupRect.width / 2
    };
  }
}
```

참조요소의 상단 가운데에 배치하는 식이다.

- top-left

```ts
export class PlacementTopLeft extends PlacementStrategy {
  getPlacementName(): Placement {
    return "top-left";
  }
  getCoordinate(): Coordinate {
    return {
      top:
        this.referenceRect.top +
        scrollY -
        this.popupRect.height -
        this.options.gap,
      left: this.referenceRect.left + scrollX
    };
  }
}
```

참조요소의 상단 좌측에 배치하는 식이다.

- top-right

```ts
export class PlacementTopRight extends PlacementStrategy {
  getPlacementName(): Placement {
    return "top-right";
  }
  getCoordinate(): Coordinate {
    return {
      top:
        this.referenceRect.top +
        scrollY -
        this.popupRect.height -
        this.options.gap,
      left: this.referenceRect.right + scrollX - this.popupRect.width
    };
  }
}
```

참조요소의 상단 우측에 배치하는 식이다.

- bottom

```ts
export class PlacementBottom extends PlacementStrategy {
  getPlacementName(): Placement {
    return "bottom";
  }
  getCoordinate(): Coordinate {
    return {
      top: this.referenceRect.bottom + this.options.gap + scrollY,
      left:
        this.referenceRect.width / 2 +
        (this.referenceRect.left + scrollX) -
        this.popupRect.width / 2,
    };
  }
```

참조요소의 하단 가운데에 배치하는 식이다.

- bottom-left

```ts
export class PlacementBottomLeft extends PlacementStrategy {
  getPlacementName(): Placement {
    return "bottom-left";
  }
  getCoordinate(): Coordinate {
    return {
      top: this.referenceRect.bottom + this.options.gap + scrollY,
      left: this.referenceRect.left + scrollX
    };
  }
}
```

참조요소의 하단 좌측에 배치하는 식이다.

- bottom-right

```ts
export class PlacementBottomRight extends PlacementStrategy {
  getPlacementName(): Placement {
    return "bottom-right";
  }
  getCoordinate(): Coordinate {
    return {
      top: this.referenceRect.bottom + this.options.gap + scrollY,
      left: this.referenceRect.right + scrollX - this.popupRect.width
    };
  }
}
```

참조요소의 하단 우측에 배치하는 식이다.

- left

```ts
export class PlacementLeft extends PlacementStrategy {
  getPlacementName(): Placement {
    return "left";
  }
  getCoordinate(): Coordinate {
    return {
      top:
        this.referenceRect.height / 2 +
        (this.referenceRect.top + scrollY) -
        this.popupRect.height / 2,
      left:
        this.referenceRect.left +
        scrollX -
        this.popupRect.width -
        this.options.gap
    };
  }
}
```

참조요소의 좌측 가운데에 배치하는 식이다.

- left-top

```ts
export class PlacementLeftTop extends PlacementStrategy {
  getPlacementName(): Placement {
    return "left-top";
  }
  getCoordinate(): Coordinate {
    return {
      top: this.referenceRect.top + scrollY,
      left:
        this.referenceRect.left +
        scrollX -
        this.popupRect.width -
        this.options.gap
    };
  }
}
```

참조요소의 좌측 상단에 배치하는 식이다.

- left-bottom

```ts
export class PlacementLeftBottom extends PlacementStrategy {
  getPlacementName(): Placement {
    return "left-bottom";
  }
  getCoordinate(): Coordinate {
    return {
      top: this.referenceRect.bottom + scrollY - this.popupRect.height,
      left:
        this.referenceRect.left +
        scrollX -
        this.popupRect.width -
        this.options.gap
    };
  }
}
```

참조요소의 좌측 하단에 배치하는 식이다.

- right

```ts
export class PlacementRight extends PlacementStrategy {
  getPlacementName(): Placement {
    return "right";
  }
  getCoordinate(): Coordinate {
    return {
      top:
        this.referenceRect.height / 2 +
        (this.referenceRect.top + scrollY) -
        this.popupRect.height / 2,
      left: this.referenceRect.right + this.options.gap + scrollX
    };
  }
}
```

참조요소의 우측 가운데에 배치하는 식이다.

- right-top

```ts
export class PlacementRightTop extends PlacementStrategy {
  getPlacementName(): Placement {
    return "right-top";
  }
  getCoordinate(): Coordinate {
    return {
      top: this.referenceRect.top + scrollY,
      left: this.referenceRect.right + this.options.gap + scrollX
    };
  }
}
```

참조요소의 우측 상단에 배치하는 식이다.

- right-bottom

```ts
export class PlacementRightBottom extends PlacementStrategy {
  getPlacementName(): Placement {
    return "right-bottom";
  }
  getCoordinate(): Coordinate {
    return {
      top: this.referenceRect.bottom + scrollY - this.popupRect.height,
      left: this.referenceRect.right + this.options.gap + scrollX
    };
  }
}
```

참조요소의 우측 하단에 배치하는 식이다.

위의 식을 받기위한 함수를 작성해야 한다.

```typescript
export const usePlacement = (
  placement: Placement,
  referenceRect: DOMRect,
  popupRect: DOMRect,
  options: Options
): PlacementStrategy => {
  const placementFactory: Record<Placement, PlacementStrategy> = {
    bottom: new PlacementBottom(referenceRect, popupRect, options),
    "bottom-left": new PlacementBottomLeft(referenceRect, popupRect, options),
    "bottom-right": new PlacementBottomRight(referenceRect, popupRect, options),
    left: new PlacementLeft(referenceRect, popupRect, options),
    "left-bottom": new PlacementLeftBottom(referenceRect, popupRect, options),
    "left-top": new PlacementLeftTop(referenceRect, popupRect, options),
    right: new PlacementRight(referenceRect, popupRect, options),
    "right-bottom": new PlacementRightBottom(referenceRect, popupRect, options),
    "right-top": new PlacementRightTop(referenceRect, popupRect, options),
    top: new PlacementTop(referenceRect, popupRect, options),
    "top-left": new PlacementTopLeft(referenceRect, popupRect, options),
    "top-right": new PlacementTopRight(referenceRect, popupRect, options)
  };
  return placementFactory[placement];
};
```

이제 이 함수를 이용하면 특정 placement의 객체를 받을 수 있다.

팝업요소의 좌표지정 계산이 이렇게 마무리 됐다. 위의 식을 잘 이용하기만 해도 팝업이나 tooltip같은 ui는 쉽게 구현할 수 있을 것이다.

## 팝업 생성

이제 팝업 구현을 위한 핵심 로직을 작성해보자.

먼저 Popup Class를 만들고, 멤버변수를 선언해준다.

```typescript
const defaultGap = 10;
const defaultPlacement: Placement = "right-top";
const defaultOptions: Options = {
  placement: defaultPlacement,
  event: {
    resize: true,
    scroll: true,
  },
  mode: {
    auto: true,
    hide: true,
    push: false,
  },
  gap: defaultGap,
};

export class Popup(){
  private options: Options;
  private referenceElement: HTMLElement;
  private popupElement: HTMLElement;
  private placementStrategy: PlacementStrategy;
  constructor(
    referenceElement: HTMLElement,
    popupElement: HTMLElement,
    options?: Options
  ) {
    this.options = { ...defaultOptions, ...options };
    this.referenceElement = referenceElement;
    this.popupElement = popupElement;
    this.update();
    document.body.insertBefore(this.popupElement, null);
  }
  // 팝업요소 업데이트 함수
  private update(): void {
    this.placementStrategy = usePlacement(
      this.options.placement,
      this.referenceElement.getBoundingClientRect(),
      this.popupElement.getBoundingClientRect(),
      this.options
    );
    this.defaultCoordinate = this.placementStrategy.getCoordinate();
    this.place(this.defaultCoordinate);
  }
  //옵션 수정 함수
  public setOptions(options: Options) {
    this.options = { ...this.options, ...options };
    this.update();
  }
  // 팝옵요소의 좌표를 지정하는 함수
  private place(coord: Coordinate): void {
    this.popupElement.style.position = "absolute";
    this.popupElement.style.top = `${coord.top}px`;
    this.popupElement.style.left = `${coord.left}px`;
  }
}
```

기본적인 틀이 완성된 팝업 클래스다.

- update : setOptions() 함수 또는 초기화 시기에 작동하는 함수다.
- place : 팝업요소의 위치를 지정하는 함수다.
- setOptions : 팝업요소의 설정을 변경하는 함수다.

팝업을 생성하는 함수를 작성하자.

```typescript
export function createPopup(
  reference: HTMLElement,
  popup: HTMLElement,
  options?: Options
): Popup {
  return new Popup(reference, popup, options);
}
```

이제 createPopup함수를 이용하여 팝업요소를 쉽게 만들 수 있게 됐다.

### 팝업요소의 style code 이용

만약 팝업요소가 참조요소의 자식요소일때 다음과 같은 상황이 올 수 있다.

```html
<div id="reference">
  <div id="popup"></div>
</div>
<style>
  .reference {
    position: relative;
    width: 200px;
    height: 200px;
  }
  .popup {
    position: absolute;
    width: 100%;
    height: 100%;
  }
</style>
```

위 상황은 팝업요소가 부모요소의 width, height값을 100%로 상속받고 싶은 상황이다.하지만 실제 작동은 body태그만큼의 width, height 값을 받게 된다.

아래는 위의 상황을 반영하기 위해 Popup Class를 수정한 코드이다.

```TypeScript
class Popup {
  //...멤버변수...
  private originPopupSize: { width: string; height: string };
  constructor(
    referenceElement: HTMLElement,
    popupElement: HTMLElement,
    options?: Options
  ) {
    // ...after this.popupElement = popupElement;
    this.originPopupSize = (() => {
      const { width, height } = getComputedStyle(popupElement);
      return { width, height };
    })();
    // ...before this.update();
  }
  private place(coord: Coordinate): void {
    this.popupElement.style.position = "absolute";
    this.popupElement.style.width = this.originPopupSize.width;
    this.popupElement.style.height = this.originPopupSize.height;
    this.popupElement.style.top = `${coord.top}px`;
    this.popupElement.style.left = `${coord.left}px`;
  }
}
```

originPopupSize 멤버변수를 선언하여 popup이 body태그에 배치되기전 width값과 height값을 받고 있다. 구조분해할당으로 값을 받아 width와 height값이 불변하도록 한다.

> getCompitedStyle(node) : 이 함수는 node의 계산된 style값을 가져오는 함수다. 읽기전용으로 값이 반환되며 요소의 스타일값이 변경될시 내부 값들도 변경된다.

## 화면 넘어감 방지
팝업요소가 viewport를 넘어가는 조건은 다음과 같다.
 - 처음 생성될때부터 viewport를 벗어난경우
 - scroll되면서 벗어난 경우
 - 화면이 resize되면서 벗어난 경우 

해당 조건은 다음과 같이 체크한다.
```TypeScript
abstract class PlacementStrategy {
  //...before code
  //overflow : true , not overflow : false
  public checkOverflow(): boolean {
    return !(
      this.coord.top >= scrollY &&
      this.coord.left >= scrollX &&
      this.coord.top + this.popupRect.height <= scrollY + innerHeight &&
      this.coord.left + this.popupRect.width <= scrollX + innerWidth
    );
  }
  //...after code
}
```
팝업요소의 top,left,bottom,right의 좌표가 viewport의 범위에 벗어나는지 확인하는 함수를 PlacementStrategy 추상 클래스에 선언한다.

Popup Class에 다음코드를 추가한다.
```TypeScript
export class Popup {
  private bindModeFunction: any;
  constructor(
    referenceElement: HTMLElement,
    popupElement: HTMLElement,
    options?: Options
  ) {
    //...
    this.bindModeFunction = throttle(this.modeManage.bind(this), 100);
    //...
  }
  private update(): void {
    //...
    this.eventManage();
    this.modeManage();
    //...
  }
  //...
  private modeManage(): void {
    this.auto();
  }
  private auto(): void {
    if (this.options.mode?.auto) {
      const placementArray: Placement[] = [
        "top",
        "top-right",
        "top-left",
        "right",
        "right-top",
        "right-bottom",
        "bottom",
        "bottom-right",
        "bottom-left",
        "left",
        "left-top",
        "left-bottom",
      ];
      if (this.placementStrategy.checkOverflow()) {
        for (const placement of placementArray) {
          const place = usePlacement(
            placement,
            this.referenceElement.getBoundingClientRect(),
            this.popupElement.getBoundingClientRect(),
            this.options
          );
          if (!place.checkOverflow()) {
            this.place(place.getCoordinate());
            break;
          }
        }
      } else {
        this.place(this.defaultCoordinate);
      }
    }
  }
  private eventManage(): void {
    if (this.options.event?.resize)
      window.addEventListener("resize", this.bindModeFunction);
    else window.removeEventListener("resize", this.bindModeFunction);
    if (this.options.event?.scroll)
      window.addEventListener("scroll", this.bindModeFunction);
    else window.removeEventListener("scroll", this.bindModeFunction);
  }
}
```
함수 하나하나씩 살펴보겠다.

```TypeScript
private auto(): void {
    if (this.options.mode?.auto) {
      const placementArray: Placement[] = [
        "top",
        "top-right",
        "top-left",
        "right",
        "right-top",
        "right-bottom",
        "bottom",
        "bottom-right",
        "bottom-left",
        "left",
        "left-top",
        "left-bottom",
      ];
      if (this.placementStrategy.checkOverflow()) {
        for (const placement of placementArray) {
          const place = usePlacement(
            placement,
            this.referenceElement.getBoundingClientRect(),
            this.popupElement.getBoundingClientRect(),
            this.options
          );
          if (!place.checkOverflow()) {
            this.place(place.getCoordinate());
            break;
          }
        }
      } else {
        this.place(this.defaultCoordinate);
      }
    }
}
```
범위를 넘었을때 실행할 auto 모드 함수를 구현한다.

초기에 등록된 placement가 overflow 됐을때 
placementArray에 등록된 순서대로 overflow를 체크하여 가장먼저 overflow가 false인것만 해당 위치를 팝업요소에 재지정한다.

초기 placement가 다시 공간이 확보된다면 else문을 통해 옵션에 설정된 placement로 위치한다.


```TypeScript
private modeManage(): void {
    this.auto();
}
```
구현한 모드 함수를 등록한다. 

옵션에 의해 수정될 수 있기에 함수를 update()에 등록한다.
```TypeScript
//constructor
this.bindModeFunction = throttle(this.modeManage.bind(this), 100);

//throttle.ts
function throttle(callback:()=>any, delay:number){
    let wait = false;
    return () => {
        if(wait) return;
        callback();
        wait = true
        setTimeout(()=>{
            wait = false
        }, delay)
    }
}
```
팝업 이벤트로 window.scroll, window.resize 이벤트를 사용할것이기 때문에 스로틀링을 구현여여 이벤트에 사용할 콜백함수로 선언했다.

>스로틀링(Throttling): 함수의 호출을 제한하여 일정한 주기나 시간 간격으로만 호출되도록 한다. 주로 이벤트 핸들러나 반복적으로 호출되는 함수에 적용되어 연속적인 호출로 인한 성능 문제를 방지하거나 원하는 주기로 함수를 실행할 때 사용된다.

```TypeScript
private eventManage(): void {
    if (this.options.event?.resize)
      window.addEventListener("resize", this.bindModeFunction);
    else window.removeEventListener("resize", this.bindModeFunction);
    if (this.options.event?.scroll)
      window.addEventListener("scroll", this.bindModeFunction);
    else window.removeEventListener("scroll", this.bindModeFunction);
}
```
옵션에 의해 true된 이벤트를 추가하고 삭제하는 로직이다.


```TypeScript
private update(): void {
    this.eventManage();
    this.modeManage();
}
```
옵션에 의해 변동될 수 있는 로직을 update에 등록한다.

위의 코드를 모두 구현했다면 createPopup을 export 하여 다른 파일에서도 사용할 수 있도록 모듈화한다.

# 사용방법
위의 코드를 모두 구현하였다면 실사용 방법은 다음과 같다.

```html
<div>
  <div class="reference"/>
  <div class="popup"/>
</div>
<script>
const referenceElement = document.querySelector('.reference')
const popupElement = document.querySelector('.popup')
const popup = createPopup(refenceElement, popupElement, {
    placement: "bottom", //or bottom-left, top, top-right, left, left-bottom ...
    mode:{
      auto:true // default = true
    },
    gap: 0 // default : 10 
});

popup.setOptions({
  placement: "top"
  mode:{
    auto:false
  },
  gap: 100
})
</script>
```

이런식으로 사용이 가능해진다.

# 마치며
한번쯤은 인터넷에 돌아다니는 라이브러리를 직접 구현해보고자 하는 생각이 들때가 있다. 이 팝업 라이브러리도 이러한 동기를 얻어 직접 만들게 되었다. 라이브러리를 직접 구현하는것보단 이미 있는것을 사용하거나, 코드를 분석하는 방법도 있겠바만, 생 바닥에서 하나하나 구현해보는것도 문제해결 능력을 기르는데는 좋은것 같다.